buildscript {
    repositories {
        mavenCentral()
    }
}

plugins {
    id 'org.springframework.boot'
    id "com.dorongold.task-tree" version "2.1.0"
    id "de.undercouch.download" version "${undercouchVersion}"
}

apply plugin: 'jacoco'

springBoot {
    buildInfo()
}

bootBuildInfo.mustRunAfter processResources

bootBuildImage {
    imageName = "$organisation/$rootProject.name:$project.version"
}

compileJava.dependsOn(processResources)

test {
    systemProperty "org.gradle.project.buildDir", "$project.buildDir"
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
    }
}

dependencies {
    file("../").eachDir { p ->
        if (p.name != "launcher") {
            implementation project(":${p.name}")
        }
    }

    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'
    implementation "engineering.everest.axon:crypto-shredding-extension:${axonCryptoShreddingVersion}"
    implementation "engineering.everest.starterkit:storage:${storageVersion}"
    implementation "engineering.everest.starterkit:media:${mediaVersion}"
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
//    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb'
    implementation 'org.keycloak:keycloak-spring-boot-starter'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation "org.axonframework:axon-micrometer:${axonVersion}"
    implementation "io.micrometer:micrometer-core:${microMeterPrometheusVersion}"
    implementation "io.micrometer:micrometer-registry-prometheus:${microMeterPrometheusVersion}"
    implementation "io.prometheus:simpleclient:${prometheusSimpleClientVersion}"
    implementation "io.prometheus:simpleclient_hotspot:${prometheusSimpleClientVersion}"
    implementation "io.prometheus:simpleclient_pushgateway:${prometheusSimpleClientVersion}"
    implementation "org.liquibase:liquibase-core:${liquibaseVersion}"
    implementation "org.postgresql:postgresql:${postgresDriverVersion}"
    implementation "com.amazonaws:aws-java-sdk-s3:${awsSdkVersion}"

    testImplementation "org.junit.jupiter:junit-jupiter:${junitVersion}"
    testImplementation "org.mockito:mockito-junit-jupiter:${mockitoVersion}"
    testImplementation "org.springframework.boot:spring-boot-starter-test"
    testImplementation "org.springframework.boot:spring-boot-starter-webflux"
    testImplementation "org.springframework.security:spring-security-test"
    testImplementation "org.apache.commons:commons-text:${commonsTextVersion}"
    testImplementation "org.bouncycastle:bcpkix-jdk15on:${bouncyCastleVersion}"
    testImplementation "org.keycloak:keycloak-admin-client:${keycloakVersion}"
    testImplementation "io.zonky.test:embedded-database-spring-test:${zonkyEmbeddedDbVersion}"
}

dependencyManagement {
    imports {
        mavenBom "org.keycloak.bom:keycloak-adapter-bom:${keycloakVersion}"
    }
}

task downloadKeycloak(type: Download) {
    outputs.cacheIf { true }
    src "https://github.com/keycloak/keycloak/releases/download/${keycloakVersion}/keycloak-${keycloakVersion}.zip"
    dest new File('/tmp', "keycloak-${keycloakVersion}.zip") // Cache between clean builds
    onlyIfModified true
}

task downloadAndUnzipKeycloak(dependsOn: downloadKeycloak, type: Copy) {
    from zipTree(downloadKeycloak.dest)
    into '/tmp'
}

task killKeycloak() {
    doLast {
        'pkill -f keycloak'.execute().waitFor()
    }
}

task keycloakTestServer(dependsOn: downloadAndUnzipKeycloak) {
    doFirst {
        Properties properties = new Properties()
        def file = project.rootProject.file('.env')
        def port, testUser, testPass
        if (file.exists()) {
            properties.load(file.newDataInputStream())
            port = properties.getProperty('KEYCLOAK_SERVER_PORT')
            testUser = properties.getProperty('KEYCLOAK_USER')
            testPass = properties.getProperty('KEYCLOAK_PASSWORD')
        }

        def keycloakDir = "/tmp/keycloak-${keycloakVersion}"
        def waitTime = 5000L

        def createUser = "$keycloakDir/bin/add-user-keycloak.sh -r master -u $testUser -p $testPass".execute()
        createUser.consumeProcessOutput(System.out, System.err)
        createUser.waitForOrKill(waitTime)

        def keycloakProcess = "$keycloakDir/bin/standalone.sh -Djboss.http.port=$port".execute()
        keycloakProcess.consumeProcessOutput(new FileOutputStream('/dev/null'), new FileOutputStream('/dev/null'))
        sleep(waitTime)

        def createRealm = "$keycloakDir/bin/kcadm.sh create realms -f $rootDir/keycloak/imports/realm-export.json --no-config --server http://localhost:$port/auth --realm master --user $testUser --password $testPass".execute()
        createRealm.consumeProcessOutput(new FileOutputStream('/dev/null'), new FileOutputStream('/dev/null'))
    }
}

task downloadAxonServer(type: Download) {
    outputs.cacheIf { true }
    src "https://download.axoniq.io/axonserver/AxonServer.zip"
    dest new File('/tmp', "axonserver.zip") // Cache between clean builds
    onlyIfModified true
}

task downloadAndUnzipAxonServer(dependsOn: downloadAxonServer, type: Copy) {
    eachFile {
        path -= ~/^.+?\//
    }
    from zipTree(downloadAxonServer.dest)
    into '/tmp/axonserver'
}

task killAxonServer() {
    doLast {
        'pkill -f axonserver'.execute().waitFor()
    }
}

task axonTestServer(dependsOn: downloadAndUnzipAxonServer) {
    doFirst {
        def axonServerDir = "/tmp/axonserver"
        def waitTime = 5000L

        def cleanupProcess = "rm -rf data".execute([] as String[], axonServerDir as File)
        cleanupProcess.consumeProcessOutput(System.out, System.err)
        cleanupProcess.waitForOrKill(waitTime)

        def axonServerProcess = "java -jar axonserver.jar".execute([] as String[], axonServerDir as File)
        axonServerProcess.consumeProcessOutput(new FileOutputStream('/dev/null'), new FileOutputStream('/dev/null'))
    }
}

test.dependsOn([keycloakTestServer, axonTestServer])
test.finalizedBy([killKeycloak, killAxonServer])
